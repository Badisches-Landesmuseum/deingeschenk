import { promisify } from 'util';
import { ReadStream } from 'fs';
import * as fs from 'fs';
import * as os from 'os';
import * as path from 'path';

import * as S3 from 'aws-sdk/clients/s3';
import * as uuidv4 from 'uuid/v4';
import * as mime from 'mime';

import { getLogger } from '../../util-libs/logging';

import { Bus } from '../bus';
import { Event, mkEvent } from './event';


const logger = getLogger('lib:storage');

// ------
// Domain
// ------

interface PreparedUpload {
  postUrl: string;
  postFields: S3.PresignedPost.Fields;
  fileName: string;
  fileUrl: string;
  fileType: string;
}

type PreparedUploadResult =
  | { kind: 'Success', data: PreparedUpload }
  | { kind: 'BadMimeType' };


// ---------
// Publishes
// ---------

const mkPreparedUploadCreatedEvent = (preparedUpload: PreparedUpload) => mkEvent(
  'prepared-upload-created',
  { preparedUpload },
);


// -------
// Service
// -------

interface StorageServiceConfig {
  bus: Bus<Event>;
  awsAccessKey: string;
  awsSecretAccessKey: string;
  awsBucket: string;
  awsRegion: string;
  prefix: string;
}


export class StorageService {

  private bus: Bus<Event>;
  private s3: S3;
  private bucket: string;
  private prefix: string;

  /**
   * Instantiate a StorageService.
   */
  public constructor(config: StorageServiceConfig) {
    this.bus = config.bus;

    this.s3 = new S3({
      credentials: {
        accessKeyId: config.awsAccessKey,
        secretAccessKey: config.awsSecretAccessKey,
      },
      params: {
        Bucket: config.awsBucket,
      },
      region: config.awsRegion,
    });

    this.bucket = config.awsBucket;
    this.prefix = config.prefix;
  }


  /**
   * Prepare pre-signed post data that can be used to upload directly to our
   * storage.
   *
   * NOTE: The uploaded file is stored in a private temporary location.
   */
  public async createPreparedUpload(mimeType: string): Promise<PreparedUploadResult> {
    const suffix = mime.getExtension(mimeType);

    if (!suffix) {
      logger.warn(`Unknown mime-type: ${mimeType}`);
      return { kind: 'BadMimeType' };
    }

    const fileName = `${uuidv4()}.${suffix}`;

    const uploadData = await this.s3.createPresignedPost({
      Fields: {
        'Key': this.generateUploadKey(fileName),
        'ACL': 'private',
        'ServerSideEncryption': 'AES256',
        'Content-Type': mimeType,
      },
      Expires: 60 * 60 * 24,
    });

    const preparedUpload = {
      postUrl: uploadData.url,
      postFields: uploadData.fields,
      fileName,
      fileUrl: `${uploadData.url}/${uploadData.fields.Key}`,
      fileType: mimeType,
    };

    this.bus.publish(mkPreparedUploadCreatedEvent(preparedUpload));
    return { kind: 'Success', data: preparedUpload };
  }


  /**
   * Retrieve an item from our user-upload storage.
   *
   * @param fileName The uploaded fileName as generated by a PreparedUpload
   */
  public async getUserUpload(fileName: string): Promise<ReadStream> {
    const getObjectRequest = this.s3.getObject({
      Bucket: this.bucket,
      Key: this.generateUploadKey(fileName),
    });
    const result = await getObjectRequest.promise();

    const filePath = path.join(os.tmpdir(), `${uuidv4()}-${fileName}`);

    try {
      await promisify(fs.writeFile)(filePath, result.Body);
      return fs.createReadStream(filePath);
    } finally {
      await promisify(fs.unlink)(filePath).catch((unlinkError) => {
        logger.error(unlinkError, 'CleanupError');
      });
    }
  }


  /**
   * Upload a file to our asset-storage.
   *
   * Assets are expected to be immutable and are stored publicly with long cache
   * headers.
   *
   * @param fileName The filename to upload as-- TODO!!! (NOTE mimeType is read from this)
   * @returns The URI of the uploaded asset
   */
  public async uploadAsset(fileName: string, body: ReadStream): Promise<string> {
    const mimeType = mime.getType(fileName);

    if (!mimeType) {
      const msg = `Unknown file-type: ${fileName}`;
      logger.warn(msg);
      throw new Error(msg);
    }

    const managedUpload = this.s3.upload({
      Bucket: this.bucket,
      Key: this.generateAssetKey(fileName),
      Body: body,
      ACL: 'public-read',
      ContentType: mimeType,
      CacheControl: PUBLIC_CACHING,
      ServerSideEncryption: 'AES256',
    });
    const sendData = await managedUpload.promise();
    return sendData.Location;
  }


  private generateUploadKey(name: string): string {
    return `${this.prefix}/uploads/${name}`;
  }


  private generateAssetKey(name: string): string {
    return `${this.prefix}/assets/${name}`;
  }
}

// -------
// Helpers
// -------

const ONE_YEAR = 31536000; // Seconds
const PUBLIC_CACHING = `public, max-age=${ONE_YEAR}, stale-while-revalidate=${ONE_YEAR}, stale-if-error=${ONE_YEAR}`;
